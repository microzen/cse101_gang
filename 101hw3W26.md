# Assignment 3

Contributors:
- Andrew Le, [aal034@ucsd.edu](mailto:aal034@ucsd.edu)
- Theo Lee, [thl030@ucsd.edu](mailto:thl030@ucsd.edu)
- Yezhi Wu, [yew020@ucsd.edu](mailto:yew020@ucsd.edu)

Due: January 29 2026

---

## Question 1
You are given a weighted undirected graph $G$ with n vertices and m edges that represents an electric vehicle network such that each edge weight represents the amount of energy consumed by going down that edge. You start at vertex $s$ and your vehicle starts at its maximum charge of $B$ energy. (You can assume $m = \Theta(n)$.)

**a).** Design an algorithm that given the information above, returns a list of all the vertices you can reach from vertex s with maximum charge of B. (4 points for reasonably efficient correct high level algorithm description (with correctness proof), 3 points for correct time analysis, and 3 points for efficiency of your algorithm.)

**High level algorithm:**

We can approach this algorithm with reduction of Dijstra's algorithm to identify the shortest distance $dist(v)$ from $s$ for all vertices in the Graph $G$, then iterating all the vertices and add the vertex for which $dist(v) \le B$ to $V'$, such that the set $V'$ includes all vertices for which $dist(v) \le B$. Then return $V'$.

**Steps of algorithm:**
1. Run the Dijstra's algorithm to compute the distance $dict(v)$ for all vertices $v$ from $s$ in graph $G$.
2. Iterate through all vertices in the graph. If $dist(v) \le B$, $add(v)$ into $V'$
3. Return $V'$

**Proof of Correctness:**

We know from class that Dijstra's algorithm will correctly compute the shortest distance $dist(v) \forall v \in V$ when the edge weights are non-negative.

Suppose the Dijstra's algorithm works correctly and all the vertices with distances $dist(v)$ are shortest path from $s$. Therefore, the iteration will go through all vertices $v \in V$ in graph $G$ such that, there are two case when reaching each vertex:
- Case 1: if $dist(v) \le B$ which is reachable, then add it to $V'$.
- Case 2: if $dist(v) \gt B$ which is unreachable, go to the next iteration. 

Therefore, the returned Set $V'$ contines eactly those vertices $v$ where $dist(v) \le B$.

**Time Analysis**
- The run time for Dijstra's with binary heap is $O((m + n)log(n))$.
- The run time for iteration is $O(n)$.
- Total time is $O((m + n)log(n)) + O(n)$, and since $m = \Theta(n)$, the runtime for my algorithm is $O(n log (n))$

**b).** Oh no!!, you can’t reach your friend’s house at vertex $t$!!! You are given the opportunity to build a charging station at one of the vertices (you can charge your battery to full charge at the charging station.) Given the graph $G$, two vertices $s$ and $t$, the cost values for each vertex $cost(v)$, and a maximum battery capacity, design an algorithm that returns the vertex with the minimum cost among all vertices at which a charging station can be built so that you can get from vertex $s$ with maximum capacity $B$ to vertex $t$. (8 points for reasonably efficient correct high level algorithm description (with correctness proof), 4 points for correct time analysis, and 3 points for efficiency of your algorithm.)

**High level algorithm:**

We can approach this algorithm by applying Dijkstra's algorithm twice to identify the short distances for both $dist_s(v)$ from the start vertex $s$ and $dist_t(v)$ from the start vertex $t$. Then, iterate all the vertices $v\in V$ in graph $G$, if $dist_s(v) \le B \text{ and } dist_t(v) \le B \text{ and } cost(v) \le cost(v_{min})$, set $v_{min} = v$, where $v_{min}$ records the minimum cost of $v$. After the iteration, return $v_{min}$.

**Steps of algorithm:**
1. Run the Dijstra's algorithm to compute the distance $dist_s(v)$ for all vertices $v$ from $s$ in graph $G$.
2. Run the Dijstra's algorithm to compute the distance $dict_t(v)$ for all vertices $v$ from $t$ in graph $G$.
3. Initialize $v_{min} = null$ to record the vertex with minimun cost, where $cost(null) = \infty$
4. Iterate through all vertices $v\in V$ in the graph $G$. If $dist_s(v) \le B \text{ and } dist_t(v) \le B \text{ and } cost(v) \lt cost(v_{min})$, set the $v_{min} = v$
5. Return $v_{min}$

**Proof of Correctness:**

We know from class that Dijstra's algorithm will correctly compute the shortest distance $dist_s(v) \text{ and } dist_t(v) \forall v \in V$ when the edge weights are non-negative.

Suppose the Dijstra's algorithm works correctly and all the vertices with distances $dist_s(v)$ are shortest path from $s$, and $dist_t(v)$ are shortest path from $t$. Therefore, the iteration will go through all vertices $v \in V$ in graph $G$ such that, there are two case when reaching each vertex:
- Case 1: if $dist_s(v) \le B \text{ and } dist_t(v) \le B \text{ and } cost(v) \lt cost(v_{min})$, which means both distances are reachable and vertex $v$'s cost is less than minimum record, then change the $cost(v)$ as minimum record.
- Otherwise: go to the next iteration. 

Since the algorithm iterates through every vertex $v\in V$ in the graph $G$, it checks all valid candidates. By tracking a running minimum variable of the vertex that is updated when a lower cost is found, the algorithm is guaranteed to hold the minimum cost by the end of the loop.

Therefore, the returned  vertex $v_{min}$ has the minimum cost for all reachable vertices which $dist_s(v) \le B \text{ and } dist_t(v) \le B$.

**Time Analysis**
- The run time for Dijstra's with binary heap is $O((m + n)log(n))$.
- The run time for iteration is $O(n)$.
- Total time is $O(2((m + n)log(n))) + O(n)$, and since $m = \Theta(n)$, the runtime for my algorithm is $O(n log (n))$


---
## Question 2
Suppose you are visiting an island nation made up of $n$ islands. There are (one-way) daily ferry services each given by $(I_d,I_a,t_d,t_a)$ where $I_d$ is the departure island, $I_a$ is the arrival island, $t_d$ is the departure time and $t_a$ is the arrival time. You can assume that each time is different and that the earliest departure time is 8 in the morning and the latest arrival time is 8 at night. You may need to spend the night on an island in order to make a connection.

(a) You start on island $s$ and wish to get to island $t$. Determine the minimum number of overnights you must spend on islands to make this journey. (8 points for reasonably efficient correct high level algorithm description (with correctness proof), 4
points for correct time analysis, and 3 points for efficiency of your algorithm.)

Algorithm Description: 

Construct a directed graph $G' = (V', E')$ where each ferry service $(I_d, I_a, t_d, t_a)$ is represented by two vertices: a departure node $(I_d, t_d)$ and an arrival node $(I_a, t_a)$. Add a directed edge with weight 0 for each ferry service from its departure node to its arrival node. For each island, sort all associated vertices by time. Add a weight-0 edge between consecutive vertices $(t_1, t_2)$ if $t_1 \le t_2$ (same-day connection), and a weight-1 edge if $t_1 > t_2$ (overnight stay). Create a source $s_{start}$ connected to all events on island $s$ and a sink $t_{end}$ connected from all events on island $t$ with weight-0 edges. Run Dijkstra's from $s_{start}$ to $t_{end}$.

Proof of Correctness: 

Each path in $G'$ corresponds to a valid sequence of ferry trips. Weight-1 edges correctly account for each overnight stay required when a connection time precedes the previous arrival. Since the algorithm finds the shortest path in this weighted graph, the resulting distance to $t_{end}$ is the minimum number of overnights.

Runtime Analysis: 

With $m$ ferry services and $n$ islands, $G'$ contains $O(m)$ vertices and $O(m)$ edges. Sorting events per island takes $O(m \log m)$. Running Dijkstra's takes $O(m \log m)$. The total runtime is $O(m \log m)$.

(b) You start on island $s$ and you wish to get to island $t$ but you want to arrive on island $t$ at the earliest possible time of day (regardless of how many overnights you spend. This is a different question.) Your algorithm should return the earliest time of day you can arrive on island $t$. (8 points for reasonably efficient correct high level algorithm description (with correctness proof), 4
points for correct time analysis, and 3 points for efficiency of your algorithm.)

Algorithm Description:

Use the graph $G'$ constructed in part (a), which contains vertices for each ferry event and edges for ferry trips, same-day connections, and overnight stays. Treat all edges in $G'$ as having weight 0 (or simply as directed unweighted edges) and run a reachability algorithm such as BFS or Explore starting from the super-source $s_{start}$. After identifying all reachable vertices, examine all arrival nodes associated with island $t$, denoted as $(t, t_a)$. The algorithm returns the minimum $t_a$ among all such reachable nodes.

Proof of Correctness:

The graph $G'$ correctly models all possible sequences of ferry journeys, with overnight edges ensuring that any arrival can eventually lead to any subsequent departure from the same island on a later day. By running a reachability traversal, the algorithm identifies every possible time of day $t_a$ at which island $t$ can be reached. Selecting the minimum $t_a$ ensures the earliest arrival time of day, regardless of the total number of overnights spent, satisfying the problem's requirement.

Runtime Analysis:

The graph $G'$ has $O(m)$ vertices and $O(m)$ edges, and its construction takes $O(m \log m)$ due to sorting. Running BFS or Explore on this graph takes $O(V' + E') = O(m)$. Finding the minimum $t_a$ among reachable nodes at island $t$ takes $O(m)$. The total runtime is $O(m \log m)$, which is consistent with the efficiency of part (a).


---
## Question 3

a) 

Base case: n = 0

$A_0$ is the only vertex. Algorithm starts at $A_n$ which is $A_0$ so $dist(A_0) = 0$ and the algorithm ejects it 1 time, and since $2^0 = 1$, base case holds.

Inductive Hypothesis:

Assume for $H(n-1)$, if we run Dijkstra algorithm starting at $A_{n-1}$, vertex $A_0$ is ejected $2^{n-1}$ times.

Inductive Step:

From H(n-1) to H(n), there is $A_n, B_{n-1}, C_{n-1}$ and H(n-1) rooted at $A_{n-1}$

From $A_n$, there are 2 ways to reach $A_{n-1}$: Path via $B_{n-1}$ with a cost of $2^{n-1}$ and path via $C_{n-1}$ with a cost of 0

Since the graph has negative edges, the algorithm first discover a path to $A_{n-1}$, but then it discovers a better path, causing $dist(A_{n-1})$ to decrease and $A_{n-1}$ is again inserted to priority queue.

Each time $A_{n-1}$ is ejected with a new best distance, the algorithm runs over the subgraph H(n-1) again because all edges in that subgraph can potentially improve distance again. And by IH, each pass ejects $A_0$ exactly $2^{n-1}$ times.

Therefore, in H(n), $A_{n-1}$'s distance is improved 2 time, and since each pass ejects $A_0$ exactly $2^{n-1}$ times, $A_0$ is ejected $2^{n-1}\cdot 2 = 2^n$ times.

Proved.

b)

From a), we proved that $A_{0}$ is ejected $2^n$ times. Therefore, the algorithm run at least $2^n$ times, or $\Omega (2^n)$

Now,

From $A_{n}$ to $A_0$, there are n + 1 vertices

From $B_{n-1}$ to $B_0$, there are n vertices

From $C_{n-1}$ to $C_0$, there are n vertices

In total, there are N = 3n + 1 vertices.

3n + 1 is a linear function of n and so, $n = \Theta (N)$

Substitute n, the algorithm runtime is $\Omega(2^{\Theta (N)})$

---
## Question 4

**Answer**:

a)

|      | A | B | C | D | E | F | G | H |
|------|---|---|---|---|---|---|---|---|
| 1    | 0 | ∞ | ∞ | ∞ | ∞ | ∞ | ∞ | ∞ |
| 2    | 0 | 1 | ∞ | ∞ | 4 | 8 | ∞ | ∞ |
| 3    | 0 | 1 | 3 | ∞ | 4 | 7 | 7 | ∞ |
| 4    | 0 | 1 | 3 | 4 | 4 | 6 | 5 | ∞ |
| 5    | 0 | 1 | 3 | 4 | 4 | 6 | 5 | 6 |

b)

<img width="905" height="416" alt="image" src="https://github.com/user-attachments/assets/c5def31b-a312-4e97-98e9-dbc0b5599766" />
---
