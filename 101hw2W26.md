# Assignment 2

Contributors:
- Andrew Le, [aal034@ucsd.edu](mailto:aal034@ucsd.edu)
- Theo Lee, [thl030@ucsd.edu](mailto:thl030@ucsd.edu)
- Yezhi Wu, [yew020@ucsd.edu](mailto:yew020@ucsd.edu)

Due: January 22 2026

---
## Question 1



---
## Question 2
(a) Algorithm1(G; a DAG G.)
Solution:
Runtime Analysis: Running DFS is O(|V| + |E|). Finding vertex h with highest post number is O(|V|). Running explore on G starting from h is O(|V| + |E|). Checking if all vertices are visited is O(|V|). Total runtime is O(|V| + |E|).
Correctness: Algorithm is not correct.
Consider the following counterexample:
```
      h → b
      ↓
      a
```
Counterexample Details:
- Graph: $V = \{h, a, b\}$, $E = \{(h, a), (h, b)\}$
- DFS Execution:
    1. Start at h (pre=1)
    2. Visit a (pre=2), Finish a (post=3) — _Backtrack to h_
    3. Visit b (pre=4), Finish b (post=5) — _Backtrack to h_
    4. Finish h (post=6)
        
- Post Numbers: $h(6) > b(5) > a(3)$

The issue is that when DFS is run, h will have the highest post number. Running explore(G, h) will visit all vertices {h, a, b}, so the algorithm will return TRUE.
It should return FALSE since there is no path from a to b and no path from b to a, meaning the graph is not semi-connected. The algorithm only checks if all vertices are reachable from one source vertex, but this doesn't guarantee that every pair of vertices has a path between them.

(b) Algorithm2(G; a DAG G.)
Solution:
Runtime Analysis: Running DFS is O(|V| + |E|). Organizing vertices by post numbers is O(|V|). The for loop runs at most once due to the bug (returns immediately after checking the first edge). Checking if (v1, v2) is an edge takes O(degree(v1)) time with an adjacency list, which is at most O(|V|). Total runtime is O(|V| + |E|).
Correctness: Algorithm is not correct.
Consider the following counterexample:
```
      a → c
      ↓
      b
```
Counterexample Details:
- Graph: $V = \{a, b, c\}$, $E = \{(a, b), (a, c)\}$
- DFS Execution:
    1. Start at a (pre=1)
    2. Visit b (pre=2), Finish b (post=3) — _Backtrack to a_
    3. Visit c (pre=4), Finish c (post=5) — _Backtrack to a_
    4. Finish a (post=6)
        
- Post Numbers: $a(6) > c(5) > b(3)$

The issue is that the algorithm returns TRUE as soon as it finds the first edge (a,c) exists, without checking if edge (c,b) exists. The return TRUE statement is inside the for loop's else block, so it returns immediately after checking only the first pair of consecutive vertices.
It should return FALSE since there is no path from b to c and no path from c to b, meaning the graph is not semi-connected.


---
## Question 3

You are given a simple directed graph G with vertex set $V$ , edge set E and edge weights $w(e) \in \{0,1\}$ as well as a starting and ending vertex $s$, $t$. Design a reasonably efficient algorithm that determines if there is a walk from $s$ to $t$ such that exactly one edge in the path has a weight of 1 (and all the rest of the edges have a weight of 0).

**Solution**:

**High level algorithm description**:

Create a graph $G'$, for each vertex $v$ of $G$, create 2 copies of each vertex in $G'$ named $v^{(1)}$ and $v^{(2)}$. 

For each edge $e=(u,v)$ in $G$.
- If $w(e)=0$, create edges $(u^{(1)},v^{(1)})$ and $(u^{(2)},v^{(2)})$ in $G'$.
- If $w(e)=1$, create edges $(u^{(1)},v^{(2)})$ in $G'$.

Run $explore(G',s^{(1)})$ and if $t^{(2)}$ is visited then reture True, otherwise return False.

**Justification of correctness**:

Suppose that graph $G$ has a path for $s$ to $t$ that goes through exactly one edge with weight 1. 

Prove the algorithm works correctly.

Then, there is a path $(s,v_1,\dots,v_n,t)$ in $G$ such that there exists exactly one edge with weight 1 in this path, and there exists edges $(v^{(1)}_i, u^{(2)}_{i+1})$ that connects $v^{(1)}$ and $v^{(2)}$ in $G'$. 

For each vertex $(v_j,v_{j+1})$ in the path before edge $e_i$ that weight 1, there exist the vertices $(v^{(1)}_j, u^{(1)}_{j+1})$ in graph $G'$. 

For each vertex $(v_k,v_{k+1})$ in the path after edge $e_i$ that weight 1, there exist the vertices $(v^{(2)}_k, u^{(2)}_{k+1})$ in graph $G'$.

Therefore, there is a path from $s^{(1)}$ to $t^{(2)}$, namely: 

$$(s^{(1)},\dots,v^{(1)}_i,v^{(2)}_{i+1},\dots,t^{(2)})$$

Therefore, when the $explore(G',s^{(1)})$ algorithm runs, $t^{(2)}$ will be visited.

Suppose the algorithm return True, then there mush be a path in $G'$ from $s^{(1)}$ to $t^{(2)}$. 

Since there is not any path from $v^{(2)}$ to $v^{(1)}$, there must be one edge with weight 1 goes $(v^{(1)}_i,v^{(2)}_{i+1})$.

Also, there exist the vertices $V_1' = (s^{(1)},v^{(1)}_i)$ which $w(V_1') = 0$, and the vertices $V_2' = (v^{(2)}_{i+1},t^{(2)})$ which $w(V_2') = 0$, and the vertices $V_3' = (v^{(1)}_i,v^{(2)}_{i+1})$ which $w(V_3') = 1$. Therefore, there exist exactly one edge that weight 1 on this path from $s^{(1)}$ to $t^{(2)}$ in $G'$.


**Runtime Analysis**:

If graph $G$ has $|V|$ vertices and $|E|$ edges, then $G'$ has $2|V|$ vertices and $2|E|$ edges. Thus, creating $G'$ takes $O(2|V| + 2|E|)$ time, which is considered as $O(|V|+|E|)$ time. Also, explore algorithm on $G'$ takes $O(|V|+|E|)$ time.

Therefore, the whole algorithm takes $O(|V|+|E|)$ time.

---
## Question 4

Suppose there is a galaxy with n planets each with its own military. There are m treaties each involving two different planets (planet A and planet B) of the form: if planet A is at war, then planet B is obligated to join the war as an ally to A.

A planet alliance bloc is a group of planets such that if any one of them is at war, all the rest of the alliance bloc will join the war as an ally (either directly or through an intermediary.)

Design an algorithm that, given a list of n planets and a list of m treaties, labels each planet with a number such that two planets in the same alliance bloc are labeled with the same number.

(8 points for reasonably efficient correct high level algorithm description (with correctness proof), 4 points for correct time analysis, and 3 points for efficiency of your algorithm.)

**Answer**:

- Algorithm Description:

  Build a directed graph G = (V,E) where each planet is a vertex, and if planet A is obligated to go to war because of planet B, then there is a directed edge from B to A.

  Run SCC on G and assign each planet a label equal to the SCC number it belongs to.

  - Runtime:

  Running SCC takes O(|V|+|E|) time, and assigning labels to all vertices takes O|V|) time. Since O(|V| + |E|) is bigger, runtime is O(|V| + |E|).

- Justification of correctness:

(Showing that planets in the same alliance bloc recieve the same label)

Consider 2 planets u and v, which are both in the same SCC. By deffinition of SCC, there is a directed path from u to v and vice versa. If one of them goes to war, then the obligations go along these paths, forcing the other planet to join. Therefore, all planets in SCC form an alliance bloc and are correctly given the same label.

(Showing that planets in different SCCs cannot be in the same alliance bloc)

Consider 2 planets u and v, which are in different SCC. This means at least 1 of them cannot be reached frrom the other. Therefore, there exist a situation that if a planet goes to war, the other is not obligated to join. Therefore, planets in different SCCs cannot be in the same alliance bloc. They recieve different labels.



